-- DATA DRIVEN ANALYTICS TO ENHANCE CUSTOMERS, PRODUCTS AND SALES STRATEGIES --
use modelcarsdb;
select * from modelcarsdb.employees;
select * from customers;
select * from offices;
select * from orderdetails;
select * from orders;
select * from payments;
select * from productlines;
select * from products;

-- TASK - 1 -- 
-- ***EMPLOYEE DATA ANALYSIS*** --
-- 1) TOTAL NUMBER OF EMPLOYEES 
select count(*) as total_no_of_employees from employees; 
-- INTERPRETATION: The total number of employees have been found, at 23

-- 2) BASIC INFORMATION OF EMPLOYEES FROM THE EMPLOYEES TABLE --
select employeeNumber, firstName, lastName, email, jobTitle from employees; 
/* INTERPRETATION: This query retrieves the basic information of employees from the 
employees table such as firstname, lastname and email etc*/

-- 3) COUNT OF THE NUMBER OF EMPLOYEES HOLDING EACH JOB TITLE --
select count(employeeNumber), jobTitle from employees group by jobTitle; 
-- INTERPRETATION: the count of employees by jobtitle have been retrieved with sales rep holding the highest no of employees

-- 4) EMPLOYEES WHO DO NOT REPORT TO  MANAGER --
select firstName, lastName, reportsTo from employees where reportsTo is null; 
-- Interpretation: This query will only return employees who do not report to anyone else, likely indicating that they are top-level managers or executives.

-- 5) TOTAL SALES GENERATED BY EACH SALES REPRESENTATIVE --
select e.employeeNumber, e.firstName, e.lastName, sum(od.quantityOrdered * od.priceEach) as total_sales, e.jobTitle from employees e join customers c on e.employeeNumber = c.salesRepEmployeeNumber 
join orders o on c.customerNumber = o.customerNumber join orderdetails od on od.orderNumber = o.orderNumber group by e.employeeNumber order by sum(od.quantityOrdered * od.priceEach) desc;
/* Interpretation: /*The SQL query you provided calculates the total sales for each employee and ranks them in descending order 
based on their total sales. This information can be used to identify top-performing sales representatives, 
evaluate sales team performance. The totales by 'Gerard Hernandez at 1267492 is the highest */

-- 6) MOST PROFITABLE SALES REPRESENTATIVE BASED ON TOTAL SATES --
select e.employeeNumber, e.firstName, e.lastName, sum(od.quantityOrdered * od.priceEach) as total_sales, e.jobTitle from employees e join customers c on e.employeeNumber = c.salesRepEmployeeNumber 
join orders o on c.customerNumber = o.customerNumber join orderdetails od on od.orderNumber = o.orderNumber group by e.employeeNumber order by sum(od.quantityOrdered * od.priceEach) desc LIMIT 1;
/*-- Interpretation: This query calculate the most profitable sales representative based on total sales.
the highest performing sales representative is Gerard Hernandez*/

-- NAMES OF ALL EMPLOYEES WHO HAVE SOLD MORE THAN THE AVERAGE_SALES_AMOUNT OF THE OFFICE --
-- FINDING AVERAGE -- (AVERAGE = '640279.374000')
select  avg(total_sales) as avg_sales from (select sum(od.quantityOrdered * od.priceEach) as total_sales from employees e join customers c on e.employeeNumber = c.salesRepEmployeeNumber 
join orders o on c.customerNumber = o.customerNumber join orderdetails od on od.orderNumber = o.orderNumber group by e.employeeNumber) as avg_sales_data;

-- 7) FINDING NAMES OF EMPLOYEES --
select concat (e.firstName,' ', e.lastName) as empl_full_name,sum(od.quantityOrdered * od.priceEach) as total_sales,
 avg(od.quantityOrdered * od.priceEach) as avg_sales
 from employees e join customers c on e.employeeNumber = c.salesRepEmployeeNumber 
join orders o on c.customerNumber = o.customerNumber 
join orderdetails od on od.orderNumber = o.orderNumber 
group by employeeNumber
having total_sales > avg_sales;
/* Interpretation: This query will provide a list of employees, their full names, total sales, and average sales, 
but only for employees whose total sales exceed their average sales. 
This can be helpful for identifying employees who consistently outperform their average performance*/
 
 -- TASK - 2 -- 
 -- ***ORDER ANALYSIS*** --
 
 select * from customers;
 select * from orders;
 select * from orderdetails;
 
 -- 1) AVERAGE ORDER AMOUNT FOR EACH CUSTOMER --
 select c.customerNumber,customerName,avg(od.quantityOrdered * od.priceEach) as order_amount from customers c join orders o
 on o.customerNumber = c.customerNumber join orderdetails od 
 on od.orderNumber = o.orderNumber group by customerNumber ;
 /* Interpretation: This query calculates the average order amount for each customer, 
 enabling analysis of customer purchasing behavior and identification of top-spending customers.*/
 
 -- 2) NUMBER OF ORDERS PLACED IN EACH MONTH --
 select monthname(orderDate) , count(*) as no_of_orders from orders o join orderdetails od on o.orderNumber = od.orderNumber group by monthname(orderDate);
 /* Interpretation: This query identifies the number of orders placed in each month
 It has been found that the month with highesr orders placed is November*/
 
 -- 3) ORDERS WITH SHIPMENT STATUS AS PENDING--
 select o.orderNumber, o.status from orders o where status = 'Pending';
  select o.orderNumber, o.status from orders o where status = 'Shipped';
-- Interpretation: This query identifies the shipment status and their corresponding order numbers--

 -- 4) ORDERSALONG WITH THEIR CUSTOMER DETAILS --
 select *, o.orderNumber from customers c join orders o on o.customerNumber = c.customerNumber order by c.customerNumber asc;
 select customerName, c.customerNumber, c.country, o.orderNumber from customers c join orders o on o.customerNumber = c.customerNumber;
/* Inference: This query provides a combined view of customer details (name, number, country) and their associated order numbers. 
It can be useful for tasks like order fulfillment, customer service inquiries, or analyzing customer ordering patterns.*/
-- Interpretation: This query identifies the order details alond with the customer details--

-- 5) MOST RECENT ORDERS BASED ON ORDERDATE --
select orderNumber, orderDate as recent_order_date from orders order by orderDate desc;
select orderNumber, max(orderDate) as recent_order_date from orders group by orderNumber order by max(orderDate) desc;
/* Inference: This query is useful for tasks like tracking recent orders, identifying the latest order numbers, 
or analyzing order trends over time.*/

-- 6) TOTAL SALES FOR EACH ORDER --
select o.orderNumber, sum(od.quantityOrdered * od.priceEach) as total_sales from orders o join orderdetails od on od.orderNumber = o.orderNumber group by o.orderNumber;
/* Inference:This query provides a list of orders, along with their total sales. 
This information can be useful for analyzing sales performance, identifying top-selling products, or tracking revenue trends*/

-- 7)THE HIGHEST VALUE ORDER BASED ON TOTAL SALES --
select o.orderNumber, sum(od.quantityOrdered * od.priceEach) as total_sales from orders o join orderdetails od on od.orderNumber = o.orderNumber group by o.orderNumber order by total_sales desc limit 1;
select * from orderdetails od  join orders o on o.orderNumber = od.orderNumber;
/* Inference: This query provides the order number and total sales of the top-selling order in the database. 
This information can be useful for identifying the most successful sales transactions,
 analyzing product popularity, or tracking sales performance.*/
 
 -- 8) ALL ORDERS WITH THEIR CORRESPONDING ORDER DETAILS --
select * from orders o join orderdetails od on o.orderNumber = od.orderNumber;
/* Interpretation: This query connects the orders and orderdetails table and provides valuable insights with the collated data*/

-- 9) THE MOST FREQUENTLY ORDERED PRODUCTS --
select pr.productName, pr.productCode, count(orderNumber) as most_frequently_ordered_products from products pr join orderdetails od on pr.productCode = od.productCode group by od.productCode order by most_frequently_ordered_products desc ;
/*Infernce: This query provides a list of products, along with their product codes and the number of times they have been ordered. 
This information can be useful for analyzing product popularity, identifying best-sellers, 
and making informed decisions about inventory management and product offerings.*/

-- 10) TOTAL REVENUE FOR EACH ORDER --
select o.orderNumber, sum(od.quantityOrdered * od.priceEach) as total_revenue from orders o join orderdetails od on od.orderNumber = o.orderNumber group by o.orderNumber order by total_revenue desc;
select o.orderNumber,sum(py.amount) as total_revenue from orders o join payments py on py.customerNumber = o.customerNumber group by o.orderNumber order by total_revenue desc;
select * from payments;
/*This query provides a list of orders, along with their total revenue. 
This information can be useful for analyzing sales performance, identifying top-selling products, or tracking revenue trends.*/

-- 11) THE MOST PROFITABLE ORDERS BASED ON TOTAL REVENUE --
select * from orders;
select * from orderdetails;
select o.orderNumber,sum(od.quantityOrdered * od.priceEach) as total_revenue from orders o join orderdetails od on od.orderNumber = o.orderNumber join products pr on
pr.productCode = od.productCode group by o.orderNumber order by total_revenue desc limit 10; 
/* Inference: This query provides the order number and total revenue of the top 10 orders in the database, 
along with the product information for each order.*/

-- 12) ALL ORDERS WITH THEIR DETAILED PRODUCT INFORMATION --
select * from products;
select o.orderNumber,pr.productCode,pr.productName,pr.productLine,pr.productDescription,od.quantityOrdered, od.priceEach,o.status from orders o join orderdetails od on od.orderNumber = o.orderNumber 
join products pr on pr.productCode = od.productCode;
/* Inference: This query provides a comprehensive view of order details, allowing us to analyze sales data, 
track product performance, and gain insights into customer behavior*/

-- 13) ORDERS WITH 'DELAYED' SHIPPING STATUS --
select orderNumber, orderDate, requiredDate, shippedDate, status as delayed_ from orders where shippedDate>requiredDate or null;
/* Inference: This query will effectively provide a list of orders, along with their order numbers, 
order dates, required dates, shipped dates, and a flag indicating whether they were delayed or not.*/

-- 14) THE MOST POPULAR PRODUCT COMBINATIONS WITHIN ORDERS --
select pr1.productName as Product1, pr2.productName as Product2, COUNT(*) AS Frequency
from orderdetails od1
join orderdetails od2 on od1.orderNumber = od2.orderNumber and od1.productCode < od2.productCode
join products pr1 on od1.productCode = pr1.productCode
join products pr2 on od2.productCode = pr2.productCode
group by pr1.productName, pr2.productName
order by Frequency desc;
-- Inference: This SQL query identifies pairs of products that are frequently ordered together in the same order.--

-- 15) REVENUE FOR EACH ORDER AND 10 MOST PROFITABLE ORDERS --
select o.orderNumber,pr.productCode,pr.productName,(od.quantityOrdered * od.priceEach) as order_revenue from orders o join orderdetails od on od.orderNumber = o.orderNumber join products pr on
pr.productCode = od.productCode order by order_revenue desc limit 10; 
/* Inference : This query provides a list of the top 10 orders with the highest total revenue, 
along with the product information for each order. This information can be useful 
for identifying the most successful sales transactions, 
analyzing product popularity, and tracking revenue trends.*/

-- 16) TRIGGER THAT AUTOMATICALLY UPDATES A CUSTOMER'S CREDIT LIMIT AFTER A NEW ORDER IS PLACED, REDUCING IT BY THE ORDER TOTAL --
Delimiter //
CREATE DEFINER = CURRENT_USER TRIGGER `modelcarsdb`.`customers_AFTER_INSERT` 
AFTER INSERT ON `orders` 
FOR EACH ROW
BEGIN
update customers 
set creditLimit= creditLimit - (select quantityOrdered*priceEach from orderdetails where orderNumber= new.orderNumber)
where customerNumber= new.customerNumber;
END //
INSERT INTO `customers` VALUES (28,'Mayuri','S','Carine ','40.32.2555','54, rue Royale',NULL,'Nantes',NULL,'44000','France',1370,41000.00);
INSERT INTO orderdetails (orderNumber,productCode,quantityOrdered,priceEach,orderLineNumber)
values (29, 'S18_4409',10,75.46,4),(29, 'S18_1749',60,136.0,3);
insert into orders(orderNumber,orderDate,requiredDate,shippedDate,status,comments,customerNumber)
values(29,'2024-09-01','2024-09-05','2024-09-03','shipped','check',114);

drop trigger customers_AFTER_INSERT;
select* from orderdetails;
select * from orders;
select * from products;
desc orders;
select * from customers;
set sql_safe_updates = 0;

/* Inference: The SQL trigger creates a mechanism to automatically update the credit limit of a customer in the customers table 
whenever a new order is placed for that customer. This ensures that the customer's available credit is accurately reflected 
after each purchase, 
preventing them from exceeding their credit limit.*/

-- 17) TRIGGER THAT LOGS PRODUCT QUANTITY CHANGES WHENEVER AN ORDER DETAIL IS UPDATED OR INSERTED --

CREATE TABLE product_quantity_log (id int auto_increment primary key,
    orderNumber int,
    productCode varchar(255),
    quantityChange int,
    newQuantity int,
    oldQuantity int, orderDate date);
    
Delimiter //
CREATE DEFINER = CURRENT_USER TRIGGER `modelcarsdb`.`product_quantity_log_AFTER_INSERT` 
AFTER INSERT ON `orderdetails` 
FOR EACH ROW
BEGIN
Declare quantity_change int;
set quantity_change = NEW.quantityOrdered - quantityOrdered;
insert into product_quantity_log (orderNumber, productCode, quantityChange, newQuantity, oldQuantity, orderDate)
values (NEW.orderNumber, productCode, quantityChange, NEW.quantityOrdered, quantityOrdered, curdate());
END //
insert into orders(orderNumber,orderDate,requiredDate,shippedDate,status,comments,customerNumber) value(1,'2024-09-22','2024-09-15',null,'shipped','check',112);
insert into orderdetails(orderNumber,productCode,quantityOrdered,priceEach,orderLineNumber) values(1, 'S18_4409',23,75.32, 31);
select * from orderdetails;
select * from orders;
select * from products;
desc orderdetails;
set sql_safe_updates = 0;
    drop trigger product_quantity_log_AFTER_INSERT;
    SELECT orderLineNumber FROM orderdetails WHERE productCode = 'S18_4409';
drop table product_quantity_log ;

/* Inference: This code effectively creates a log of product quantity changes whenever a new order detail is added.
 It records the order number, product code, change in quantity, new quantity, old quantity, and order date for each change.
 This can be helpful for tracking inventory levels, analyzing sales trends, and identifying product popularity.*/
 
 -- --------------------------- *********************TASKS COMPLETED****************************** ------------------------------------------
